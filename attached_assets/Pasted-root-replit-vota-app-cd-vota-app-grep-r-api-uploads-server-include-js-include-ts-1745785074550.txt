root@replit:~/vota-app# cd ~/vota-app
grep -r "/api/uploads" server --include="*.js" --include="*.ts"
server/routes.ts:  router.post("/api/uploads", async (req, res) => {
server/routes.ts:  router.get("/api/uploads/:id", async (req, res) => {
server/routes.ts:      console.error("Error in /api/uploads/:id route:", error);
root@replit:~/vota-app# cd ~/vota-app
grep -r "app.post('/api/uploads'" server --include="*.js" --include="*.ts"
root@replit:~/vota-app# cd ~/vota-app
grep -r "router.post('/uploads'" server --include="*.js" --include="*.ts"
root@replit:~/vota-app# cd ~/vota-app
cat server/routes.ts
import express from "express";
import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { 
  insertVideoSchema, 
  insertUserUploadSchema, 
  insertUserSchema 
} from "@shared/schema";
import { z } from "zod";
import { costTrackerService } from "./services/costTracker";
import { replicateService } from "./services/replicate";
import { emailService } from "./services/emailService";
import debugRouter from "./routes/debug";
import proxyRouter from "./routes/proxy";

export async function registerRoutes(app: Express): Promise<Server> {
  const router = express.Router();

  // API endpoint to upload user video
  router.post("/api/uploads", async (req, res) => {
    try {
      console.log("Video upload started, validating payload...");
      
      // Add size limit checks first
      if (req.body.videoData && typeof req.body.videoData === 'string') {
        const dataSize = req.body.videoData.length;
        const sizeInMB = Math.round((dataSize / (1024 * 1024)) * 100) / 100;
        console.log(`Video data size: ${sizeInMB} MB`);
        
        // Warn if video is very large
        if (dataSize > 20 * 1024 * 1024) { // Over 20MB
          console.warn(`Large video upload detected: ${sizeInMB}MB. This may cause performance issues.`);
        }
      }
      
      const { videoData, userId, metadata } = insertUserUploadSchema.parse({
        ...req.body,
        createdAt: new Date().toISOString(),
      });

      console.log(`Creating upload record for user ${userId}...`);
      
      // Create a user upload record - but don't store the full video in the DB
      // Just store a placeholder to prevent DB bloat
      const userUpload = await storage.createUserUpload({
        userId,
        videoData: "VIDEO_DATA_PROCESSED", // Don't store large video data in DB
        metadata: JSON.stringify({
          originalSize: videoData.length,
          uploadDate: new Date().toISOString(),
          deviceInfo: metadata && typeof metadata === 'object' ? metadata : {}
        })
      });
      
      // Set the processing status
      await storage.updateUserUpload(userUpload.id, {
        processingStatus: 'processing'
      });

      console.log(`Upload record created with ID ${userUpload.id}, starting face extraction...`);

      // Process the video for face extraction in background
      // First return success response to client
      res.status(200).json({
        message: "Video upload successful, processing started",
        uploadId: userUpload.id
      });
      
      // Then process in background (don't await)
      (async () => {
        try {
          console.log("Extracting face from uploaded video...");
          // Extract face from the uploaded video
          const faceImageUrl = await replicateService.extractFace(videoData, Number(userId));
          console.log("Face extraction completed successfully");
          
          // Update the user upload with the face image URL and set status to completed
          await storage.updateUserUpload(userUpload.id, {
            faceImageUrl,
            processingStatus: 'completed'
          });
          
          // Update the user record with the face image URL
          const user = await storage.getUser(Number(userId));
          if (user) {
            await storage.updateUser(user.id, {
              faceImageUrl,
              processingStatus: 'completed'
            });
            
            // Send email notification for face extraction completion if user has email
            if (user.email) {
              try {
                await emailService.sendFaceExtractionCompleteNotification(user, userUpload.id);
                console.log(`Face extraction completion email sent to ${user.email}`);
              } catch (emailError) {
                console.error("Error sending face extraction completion email:", emailError);
                // Continue even if email fails
              }
            }
          }
        } catch (err) {
          const error = err as Error;
          console.error("Error processing user video:", error);
          
          // Provide a more helpful error message
          let userFriendlyMessage = "We couldn't process your video. Please try recording in better lighting or try a different pose.";
          
          if (error.message.includes("Unknown error")) {
            userFriendlyMessage = "We're experiencing temporary issues with our video processing. Please try again later.";
          } else if (error.message.includes("422") || error.message.includes("unprocessable")) {
            userFriendlyMessage = "Your video couldn't be analyzed properly. Try recording with your face clearly visible, in good lighting.";
          }
          
          // Update upload status on error
          await storage.updateUserUpload(userUpload.id, {
            processingStatus: 'failed',
            errorMessage: userFriendlyMessage,
            // Store the technical error details in metadata for debugging
            metadata: JSON.stringify({
              technicalError: error.message,
              errorTimestamp: new Date().toISOString()
            })
          });
          
          console.error("Face extraction failed: ", error.message || "Unknown error");
        }
      })().catch(err => {
        console.error("Unhandled error in background processing:", err);
      });
      
    } catch (error) {
      console.error("Error processing upload request:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to upload video", error: (error as Error).message || "Unknown error" });
    }
  });

  // API endpoint to check upload status
  router.get("/api/uploads/:id", async (req, res) => {
    try {
      const userUpload = await storage.getUserUpload(Number(req.params.id));
      if (!userUpload) {
        return res.status(404).json({ message: "Upload not found" });
      }

      // Even if failed, we want to return with 200 status so the frontend can show the error message
      // This is more user-friendly than a 500 server error
      if (userUpload.processingStatus === 'failed') {
        return res.status(200).json({
          ...userUpload,
          message: userUpload.errorMessage || "Processing failed, but we're working on making it better!"
        });
      }

      // If the upload is already completed, just return it
      if (userUpload.processingStatus === 'completed') {
        return res.status(200).json(userUpload);
      }

      // Get user
      const user = await storage.getUser(Number(userUpload.userId));
      if (!user) {
        // For now, just create a default user with this ID if it doesn't exist
        try {
          // Use ID 1 as default in case the user doesn't exist
          const defaultUserId = Number(userUpload.userId) || 1;
          await storage.createUser({
            username: `user_${defaultUserId}`,
            password: 'default_password',
            email: null,
            // The ID will be assigned automatically
          });
        } catch (userCreateError) {
          console.log("Failed to create user automatically:", userCreateError);
          // Continue anyway
        }
      }
      
      // Return with the current status, even if it's still processing
      return res.status(200).json({
        ...userUpload,
        message: "Your video is being processed. This may take a few moments."
      });
    } catch (error) {
      console.error("Error in /api/uploads/:id route:", error);
      
      // Even for errors, we want a 200 response with error details to handle gracefully in the frontend
      return res.status(200).json({ 
        id: Number(req.params.id),
        processingStatus: 'failed',
        message: "There was an error checking your upload status. Please try again.",
        errorDetails: (error as Error).message 
      });
    }
  });

  // API endpoint to generate video
  router.post("/api/videos", async (req, res) => {
    try {
      // Get the data from the request and pass it through the schema validation
      const validatedData = insertVideoSchema.parse({
        ...req.body,
        status: 'processing', // Always start with processing
        createdAt: new Date().toISOString(),
      });
      
      // Extract the fields including the email field which is in the extended schema
      const { prompt, userId, title, negativePrompt, aspectRatio, duration, cfgScale, email } = validatedData;

      // Get the user to check for face image
      const user = await storage.getUser(Number(userId));
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Check if user has an extracted face image
      if (!user.faceImageUrl) {
        return res.status(400).json({ 
          message: "User does not have a profile image. Please upload a video first." 
        });
      }

      // Create a video entry in the database
      // Use a string format for the userId since our schema now handles conversion
      const video = await storage.createVideo({
        userId: userId, // Passed as string, our schema now handles conversion 
        title,
        prompt,
        notificationEmail: email, // Save the email address for notifications
        negativePrompt: negativePrompt || "",
        aspectRatio: aspectRatio || "16:9",
        duration: duration || "5",
        cfgScale: cfgScale || "0.5"
      });
      
      // Set status to processing explicitly
      await storage.updateVideoStatus(video.id, 'processing');

      // Start video generation with Replicate API
      try {
        // Generate the base video using Stable Video Diffusion model
        const options = {
          negativePrompt: negativePrompt || "",
          aspectRatio: aspectRatio || "9:16", // Using portrait mode (9:16) for mobile devices
          duration: duration || "5",
          cfgScale: cfgScale || "7.5" // Replicate service will convert this to a number
        };
        
        console.log(`Video generation started for user ${userId} with prompt: ${prompt}`);
        console.log(`Using options:`, JSON.stringify(options));
        
        // Ensure we have the user's face image
        console.log(`User face image URL: ${user.faceImageUrl}`);
        
        // Check Replicate API connection before trying generation
        try {
          console.log("Testing Replicate API connection before generating video...");
          const connectionTest = await replicateService.testConnection();
          console.log("Replicate API connection test result:", JSON.stringify(connectionTest));
          
          if (!connectionTest.success) {
            console.error("Replicate API connection failed:", connectionTest.message);
            throw new Error(`Replicate API connection failed: ${connectionTest.message}`);
          }
          
          // First, enable debug mode to see detailed logs
          replicateService.setDebugMode(true);
          
          // Make sure userId is a number for the Replicate service
          const userIdNum = Number(userId);
          console.log(`Converting userId from ${userId} (${typeof userId}) to ${userIdNum} (${typeof userIdNum})`);
          
          // Verify API token is not empty
          if (!process.env.REPLICATE_API_TOKEN) {
            console.error("REPLICATE_API_TOKEN is not set or is empty");
            throw new Error("REPLICATE_API_TOKEN is not set or is empty");
          }
          console.log("REPLICATE_API_TOKEN is set (length:", process.env.REPLICATE_API_TOKEN.length, "characters)");
          
          console.log("Calling Replicate API to generate video...");
          const generateResult = await replicateService.generateVideo(prompt, userIdNum, options);
          console.log(`Video generation API response:`, JSON.stringify(generateResult));
          
          // Store the prediction ID in the database
          await storage.updateVideo(video.id, {
            requestId: generateResult.id
          });
        } catch (error) {
          const generateError = error as Error;
          console.error(`DETAILED ERROR in video generation:`, generateError);
          // Show more details about network-related errors
          if ('cause' in generateError && generateError.cause) {
            console.error("Error cause:", generateError.cause);
          }
          throw generateError;
        }

        return res.status(200).json({
          message: "Video generation started",
          videoId: video.id,
          status: 'processing'
        });
      } catch (err) {
        console.error("Error in video generation:", err);
        // Update video status on error
        await storage.updateVideoStatus(video.id, 'failed');
        return res.status(500).json({ 
          message: "Failed to start video generation", 
          error: (err as Error).message || "Unknown error" 
        });
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to generate video", error });
    }
  });

  // API endpoint to get a specific video and check its status
  router.get("/api/videos/:id", async (req, res) => {
    try {
      const video = await storage.getVideo(Number(req.params.id));
      if (!video) {
        return res.status(404).json({ message: "Video not found" });
      }

      // If video is already completed or failed, just return it
      if (video.status === 'completed' || video.status === 'failed') {
        return res.status(200).json(video);
      }

      // If the video is in processing state and has a request_id, check with Replicate
      try {
        if (!video.requestId) {
          return res.status(200).json({
            ...video,
            message: "Waiting for generation to start"
          });
        }
        
        // Check the status with Replicate
        const statusResult = await replicateService.checkVideoStatus(video.requestId, Number(video.userId));
        
        if (statusResult.status === 'succeeded' && statusResult.output) {
          // If video generation succeeded, we need to apply face swap
          // Handle the case where output could be an array
          const videoUrl = Array.isArray(statusResult.output) 
            ? statusResult.output[0] 
            : statusResult.output as string;
            
          const user = await storage.getUser(Number(video.userId));
          
          if (user && user.faceImageUrl) {
            // Now apply face swap
            const swapResult = await replicateService.swapFace(videoUrl, user.faceImageUrl, Number(video.userId));
            
            // Update the video with the face swap request ID
            await storage.updateVideo(video.id, {
              rawVideoUrl: videoUrl, // Store the original video URL
              requestId: swapResult.id // Update with face swap request ID
            });
            
            return res.status(200).json({
              ...video,
              status: 'processing',
              message: "Face swap in progress",
              progress: 0.5
            });
          } else {
            // No face image available, just use the generated video
            const updatedVideo = await storage.updateVideo(video.id, {
              status: 'completed',
              videoUrl
            });
            
            // Get the user to send notification
            const user = await storage.getUser(Number(video.userId));
            if (user && user.email && updatedVideo) {
              try {
                await emailService.sendVideoGenerationCompleteNotification(user, updatedVideo);
                console.log(`Video completion email sent to ${user.email}`);
              } catch (emailError) {
                console.error("Error sending video completion email:", emailError);
                // Continue even if email fails
              }
            }
            
            return res.status(200).json({
              ...video,
              status: 'completed',
              videoUrl
            });
          }
        } else if (statusResult.status === 'failed') {
          // Update video status to failed
          await storage.updateVideoStatus(video.id, 'failed');
          return res.status(200).json({
            ...video,
            status: 'failed',
            error: statusResult.error
          });
        } else if (video.rawVideoUrl && statusResult.status !== 'succeeded') {
          // We're in the face swap phase
          // Check face swap status
          const swapStatusResult = await replicateService.checkFaceSwapStatus(video.requestId, Number(video.userId));
          
          if (swapStatusResult.status === 'succeeded' && swapStatusResult.output) {
            // Face swap completed, update the video
            // Handle the case where output could be an array
            const swappedVideoUrl = Array.isArray(swapStatusResult.output) 
              ? swapStatusResult.output[0] 
              : swapStatusResult.output as string;
              
            const updatedVideo = await storage.updateVideo(video.id, {
              status: 'completed',
              videoUrl: swappedVideoUrl,
              thumbnailUrl: video.rawVideoUrl // Use first frame of the original video as thumbnail
            });
            
            // Get the user to send notification
            const user = await storage.getUser(Number(video.userId));
            if (user && user.email && updatedVideo) {
              try {
                await emailService.sendVideoGenerationCompleteNotification(user, updatedVideo);
                console.log(`Video completion email sent to ${user.email}`);
              } catch (emailError) {
                console.error("Error sending video completion email:", emailError);
                // Continue even if email fails
              }
            }
            
            return res.status(200).json({
              ...video,
              status: 'completed',
              videoUrl: swapStatusResult.output
            });
          } else if (swapStatusResult.status === 'failed') {
            // Face swap failed, use the original video
            const updatedVideo = await storage.updateVideo(video.id, {
              status: 'completed',
              videoUrl: video.rawVideoUrl,
              errorMessage: swapStatusResult.error
            });
            
            // Get the user to send notification
            const user = await storage.getUser(Number(video.userId));
            if (user && user.email && updatedVideo) {
              try {
                await emailService.sendVideoGenerationCompleteNotification(user, updatedVideo);
                console.log(`Video completion email sent to ${user.email} (fallback to original video)`);
              } catch (emailError) {
                console.error("Error sending video completion email:", emailError);
                // Continue even if email fails
              }
            }
            
            return res.status(200).json({
              ...video,
              status: 'completed',
              videoUrl: video.rawVideoUrl,
              errorMessage: "Face swap failed, showing original video"
            });
          } else {
            // Still processing face swap
            return res.status(200).json({
              ...video,
              status: 'processing',
              message: "Face swap in progress",
              progress: 0.7
            });
          }
        } else {
          // Still processing
          return res.status(200).json({
            ...video,
            status: 'processing',
            message: "Video generation in progress",
            progress: 0.3
          });
        }
      } catch (err) {
        console.error("Error checking video generation status:", err);
        // Don't update status on API error
        return res.status(200).json({
          ...video,
          error: (err as Error).message
        });
      }
    } catch (error) {
      return res.status(500).json({ message: "Failed to get video", error });
    }
  });

  // API endpoint to get all videos for a user
  router.get("/api/users/:userId/videos", async (req, res) => {
    try {
      const videos = await storage.getVideosByUserId(Number(req.params.userId));
      return res.status(200).json(videos);
    } catch (error) {
      return res.status(500).json({ message: "Failed to get user videos", error });
    }
  });
  
  // API endpoint to create a user
  router.post("/api/users", async (req, res) => {
    try {
      const { username, password } = insertUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already exists" });
      }
      
      // Create the user
      const user = await storage.createUser({ username, password });
      
      // Remove password from response
      const { password: _, ...userWithoutPassword } = user;
      
      return res.status(200).json(userWithoutPassword);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      return res.status(500).json({ message: "Failed to create user", error });
    }
  });

  // API endpoint to get API usage costs for a user
  router.get("/api/users/:userId/api-usage", async (req, res) => {
    try {
      const userId = Number(req.params.userId);
      
      // Get cost summary for user
      const costSummary = await costTrackerService.getUserCosts(userId);
      
      // Get latest API usage records for user
      const apiUsageRecords = await storage.getApiUsageByUserId(userId);
      
      return res.status(200).json({
        ...costSummary,
        recentUsage: apiUsageRecords.slice(0, 10) // Only return the 10 most recent records
      });
    } catch (error) {
      return res.status(500).json({ 
        message: "Failed to get API usage information", 
        error: (error as Error).message 
      });
    }
  });
  
  // API endpoint to get total API usage costs for system monitoring
  router.get("/api/admin/api-usage", async (req, res) => {
    try {
      // Get total cost across all users
      const totalCost = await costTrackerService.getTotalCosts();
      
      return res.status(200).json({
        totalCost,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      return res.status(500).json({ 
        message: "Failed to get total API usage information", 
        error: (error as Error).message 
      });
    }
  });
  
  // Register the main API routes
  app.use(router);
  
  // Quick test endpoint for Replicate API
  app.get('/api/test-replicate', async (req, res) => {
    try {
      // Check if REPLICATE_API_TOKEN is set
      const apiToken = process.env.REPLICATE_API_TOKEN || '';
      const hasToken = !!apiToken;
      const tokenLength = apiToken.length;
      
      console.log(`REPLICATE_API_TOKEN check: exists=${hasToken}, length=${tokenLength}`);
      
      if (!hasToken) {
        return res.status(500).json({
          success: false,
          message: "REPLICATE_API_TOKEN is not set in environment variables",
          hasToken: false
        });
      }
      
      // Test the API connection
      const connectionResult = await replicateService.testConnection();
      
      return res.status(200).json({
        ...connectionResult,
        hasToken: true,
        tokenLength: tokenLength
      });
    } catch (error) {
      console.error("Error testing Replicate API:", error);
      return res.status(500).json({ 
        success: false,
        message: "Failed to test Replicate API", 
        error: (error as Error).message,
        hasToken: !!(process.env.REPLICATE_API_TOKEN || ''),
        tokenLength: (process.env.REPLICATE_API_TOKEN || '').length
      });
    }
  });

  // Register debug routes (only available in development)
  app.use('/api/debug', debugRouter);
  
  // Register proxy routes for external API access
  app.use('/api', proxyRouter);

  const httpServer = createServer(app);
  return httpServer;
}
root@replit:~/vota-app# cd ~/vota-app
grep -A50 "router.post(\"/api/uploads\"" server/routes.ts
  router.post("/api/uploads", async (req, res) => {
    try {
      console.log("Video upload started, validating payload...");
      
      // Add size limit checks first
      if (req.body.videoData && typeof req.body.videoData === 'string') {
        const dataSize = req.body.videoData.length;
        const sizeInMB = Math.round((dataSize / (1024 * 1024)) * 100) / 100;
        console.log(`Video data size: ${sizeInMB} MB`);
        
        // Warn if video is very large
        if (dataSize > 20 * 1024 * 1024) { // Over 20MB
          console.warn(`Large video upload detected: ${sizeInMB}MB. This may cause performance issues.`);
        }
      }
      
      const { videoData, userId, metadata } = insertUserUploadSchema.parse({
        ...req.body,
        createdAt: new Date().toISOString(),
      });

      console.log(`Creating upload record for user ${userId}...`);
      
      // Create a user upload record - but don't store the full video in the DB
      // Just store a placeholder to prevent DB bloat
      const userUpload = await storage.createUserUpload({
        userId,
        videoData: "VIDEO_DATA_PROCESSED", // Don't store large video data in DB
        metadata: JSON.stringify({
          originalSize: videoData.length,
          uploadDate: new Date().toISOString(),
          deviceInfo: metadata && typeof metadata === 'object' ? metadata : {}
        })
      });
      
      // Set the processing status
      await storage.updateUserUpload(userUpload.id, {
        processingStatus: 'processing'
      });

      console.log(`Upload record created with ID ${userUpload.id}, starting face extraction...`);

      // Process the video for face extraction in background
      // First return success response to client
      res.status(200).json({
        message: "Video upload successful, processing started",
        uploadId: userUpload.id
      });
      
      // Then process in background (don't await)
      (async () => {
root@replit:~/vota-app# cd ~/vota-app
grep -r "ws:" server --include="*.js" --include="*.ts"
grep -r "wss:" server --include="*.js" --include="*.ts"
root@replit:~/vota-app# cd ~/vota-app
sed -n '/router.post("\/api\/uploads"/,/});/p' server/routes.ts
  router.post("/api/uploads", async (req, res) => {
    try {
      console.log("Video upload started, validating payload...");
      
      // Add size limit checks first
      if (req.body.videoData && typeof req.body.videoData === 'string') {
        const dataSize = req.body.videoData.length;
        const sizeInMB = Math.round((dataSize / (1024 * 1024)) * 100) / 100;
        console.log(`Video data size: ${sizeInMB} MB`);
        
        // Warn if video is very large
        if (dataSize > 20 * 1024 * 1024) { // Over 20MB
          console.warn(`Large video upload detected: ${sizeInMB}MB. This may cause performance issues.`);
        }
      }
      
      const { videoData, userId, metadata } = insertUserUploadSchema.parse({
        ...req.body,
        createdAt: new Date().toISOString(),
      });
root@replit:~/vota-app# cd ~/vota-app
grep -r "replicate" server --include="*.js" --include="*.ts"
grep -r "fal" server --include="*.js" --include="*.ts"
server/routes/debug.ts: * - GET /api/debug/replicate/test-connection - Test connection to Replicate API
server/routes/debug.ts:import { replicateService } from '../services/replicate';
server/routes/debug.ts:        testReplicateConnection: '/api/debug/replicate/test-connection',
server/routes/debug.ts:debugRouter.get('/replicate/test-connection', async (req: Request, res: Response) => {
server/routes/debug.ts:      replicateService.setDebugMode(true);
server/routes/debug.ts:    const connectionResult = await replicateService.testConnection();
server/routes/debug.ts:      apiUrl: 'https://api.replicate.com/v1/predictions',
server/routes/debug.ts:debugRouter.get('/replicate/test-video-generation', async (req: Request, res: Response) => {
server/routes/debug.ts:    replicateService.setDebugMode(true);
server/routes/debug.ts:        endpoint: 'replicate/development-mode',
server/routes/debug.ts:        checkStatusUrl: `/api/debug/replicate/generation-status/${mockPredictionId}?userId=${userId}`
server/routes/debug.ts:    replicateService.setDebugMode(true);
server/routes/debug.ts:    const generateResult = await replicateService.generateVideo(prompt, userId, options);
server/routes/debug.ts:      checkStatusUrl: `/api/debug/replicate/generation-status/${generateResult.id}?userId=${userId}`
server/routes/debug.ts:debugRouter.get('/replicate/generation-status/:predictionId', async (req: Request, res: Response) => {
server/routes/debug.ts:        endpoint: 'replicate/status-check-dev',
server/routes/debug.ts:    const statusResult = await replicateService.checkVideoStatus(predictionId, userId);
server/services/replicate.ts:const REPLICATE_API_URL = 'https://api.replicate.com/v1/predictions';
server/services/replicate.ts:      const response = await fetch('https://api.replicate.com/v1', {
server/services/replicate.ts:          'replicate/primary-model-error',
server/services/replicate.ts:                `replicate/backup-model-${i+1}-success`,
server/services/replicate.ts:              `replicate/backup-model-${i+1}-error`,
server/services/replicate.ts:        'replicate/stable-video-diffusion',
server/services/replicate.ts:        'replicate/stable-video-diffusion',
server/services/replicate.ts:          'replicate/status-check',
server/services/replicate.ts:        'replicate/status-check',
server/services/replicate.ts:        'replicate/status-check',
server/services/replicate.ts:          'replicate/face-swap',
server/services/replicate.ts:        'replicate/face-swap',
server/services/replicate.ts:        'replicate/face-swap',
server/services/replicate.ts:        'replicate/status-check',
server/services/replicate.ts:        'replicate/status-check',
server/services/replicate.ts:          'replicate/face-extraction',
server/services/replicate.ts:        return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
server/services/replicate.ts:            'replicate/face-extraction',
server/services/replicate.ts:          return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
server/services/replicate.ts:          'replicate/face-extraction',
server/services/replicate.ts:        return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
server/services/replicate.ts:        'replicate/face-extraction',
server/services/replicate.ts:        'replicate/face-extraction',
server/services/replicate.ts:      return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
server/services/replicate.ts:export const replicateService = new ReplicateService();
server/services/costTracker.ts:  'replicate/kling-video-generation': 0.05, // $0.05 per video generation
server/services/costTracker.ts:  'replicate/face-swap': 0.03, // $0.03 per face swap operation
server/services/costTracker.ts:  'replicate/status-check': 0.001, // $0.001 per status check (minimal cost)
server/routes.ts:import { replicateService } from "./services/replicate";
server/routes.ts:          const faceImageUrl = await replicateService.extractFace(videoData, Number(userId));
server/routes.ts:          const connectionTest = await replicateService.testConnection();
server/routes.ts:          replicateService.setDebugMode(true);
server/routes.ts:          const generateResult = await replicateService.generateVideo(prompt, userIdNum, options);
server/routes.ts:        const statusResult = await replicateService.checkVideoStatus(video.requestId, Number(video.userId));
server/routes.ts:            const swapResult = await replicateService.swapFace(videoUrl, user.faceImageUrl, Number(video.userId));
server/routes.ts:          const swapStatusResult = await replicateService.checkFaceSwapStatus(video.requestId, Number(video.userId));
server/routes.ts:  app.get('/api/test-replicate', async (req, res) => {
server/routes.ts:      const connectionResult = await replicateService.testConnection();
server/direct-video-test.ts:import { replicateService } from './services/replicate';
server/direct-video-test.ts:  replicateService.setDebugMode(true);
server/direct-video-test.ts:    const connectionResult = await replicateService.testConnection();
server/direct-video-test.ts:    const result = await replicateService.generateVideo(
server/direct-video-test.ts:        const statusResult = await replicateService.checkVideoStatus(result.id, 999);
server/routes/proxy.ts:import { FalConfigError } from '../services/falai-errors';
server/routes/proxy.ts:  'fal': 'https://api.fal.ai' // Direct URL as fallback
server/routes/proxy.ts:  'https://34.142.140.121', // Possible IP for api.fal.ai
server/routes/proxy.ts:proxyRouter.use('/fal-proxy/*', createProxyMiddleware({
server/routes/proxy.ts:  target: API_ENDPOINTS.fal,
server/routes/proxy.ts:    '^/api/fal-proxy': ''  // Remove '/api/fal-proxy' and use the rest as the request path
server/routes/proxy.ts:      console.log(`[PROXY] ${req.method} ${req.url} -> ${API_ENDPOINTS.fal}${req.url?.replace('/api/fal-proxy', '')}`);
server/routes/proxy.ts:// Add separate routes for each alternate IP as fallbacks
server/routes/proxy.ts:  proxyRouter.use(`/fal-proxy-alt${index + 1}/*`, createProxyMiddleware({
server/routes/proxy.ts:      [`^/api/fal-proxy-alt${index + 1}`]: ''  // Remove '/api/fal-proxy-altX' and use the rest as the request path
server/routes/proxy.ts:      console.log(`[PROXY-ALT${index + 1}] ${req.method} ${req.url} -> ${ip}${req.url?.replace(`/api/fal-proxy-alt${index + 1}`, '')}`);
server/routes/debug.ts: * - POST /api/debug/falai/debug/:enabled - Enable or disable Fal.ai debug mode
server/routes/debug.ts: * - GET /api/debug/falai/training-status/:loraId - Check training status for a specific LoRA ID
server/routes/debug.ts: * - GET /api/debug/falai/generation-status/:requestId - Check generation status for a specific request ID
server/routes/debug.ts: * - GET /api/debug/falai/test-connection - Test connection to Fal.ai API
server/routes/debug.ts:import { falaiService } from '../services/falai';
server/routes/debug.ts:    falDebugMode: falaiService.isDebugMode(),
server/routes/debug.ts:      falai: {
server/routes/debug.ts:        train: falaiService.getTrainEndpoint(),
server/routes/debug.ts:        generate: falaiService.getGenerateEndpoint(),
server/routes/debug.ts:        checkTraining: falaiService.getTrainingStatusEndpoint(':loraId'),
server/routes/debug.ts:        checkGeneration: falaiService.getGenerationStatusEndpoint(':requestId'),
server/routes/debug.ts:        falaiDebugToggle: '/api/debug/falai/debug/:enabled',
server/routes/debug.ts:        checkTrainingStatus: '/api/debug/falai/training-status/:loraId',
server/routes/debug.ts:        checkGenerationStatus: '/api/debug/falai/generation-status/:requestId',
server/routes/debug.ts:        testFalaiConnection: '/api/debug/falai/test-connection',
server/routes/debug.ts:debugRouter.post('/falai/debug/:enabled', (req: Request, res: Response) => {
server/routes/debug.ts:  falaiService.setDebugMode(enabled);
server/routes/debug.ts:debugRouter.get('/falai/training-status/:loraId', async (req: Request, res: Response) => {
server/routes/debug.ts:    const result = await falaiService.checkTrainingStatus(loraId, userId);
server/routes/debug.ts:debugRouter.get('/falai/generation-status/:requestId', async (req: Request, res: Response) => {
server/routes/debug.ts:    const result = await falaiService.checkGenerationStatus(requestId, userId);
server/routes/debug.ts:debugRouter.get('/falai/test-connection', async (req: Request, res: Response) => {
server/routes/debug.ts:      falaiService.setDebugMode(true);
server/routes/debug.ts:        train: falaiService.getTrainEndpoint(),
server/routes/debug.ts:        generate: falaiService.getGenerateEndpoint(),
server/routes/debug.ts:        checkTraining: falaiService.getTrainingStatusEndpoint('test-id'),
server/routes/debug.ts:        checkGeneration: falaiService.getGenerationStatusEndpoint('test-id'),
server/routes/debug.ts:        "To check an actual training status, use /api/debug/falai/training-status/:loraId",
server/routes/debug.ts:        "To check an actual generation status, use /api/debug/falai/generation-status/:requestId",
server/routes/debug.ts:        "To toggle debug mode, use /api/debug/falai/debug/true or /api/debug/falai/debug/false"
server/routes/debug.ts:      success: false,
server/routes/debug.ts:      success: false,
server/routes/debug.ts:      success: false,
server/test-falai.ts: *     npx tsx server/test-falai.ts
server/test-falai.ts: *     npx tsx server/test-falai.ts training <lora-id>
server/test-falai.ts: *     npx tsx server/test-falai.ts generation <request-id>
server/test-falai.ts:import { falaiService } from './services/falai';
server/test-falai.ts:import { FalConfigError, FalAuthError, FalApiError } from './services/falai-errors';
server/test-falai.ts:    falaiService.setDebugMode(true);
server/test-falai.ts:    console.log('Train endpoint:', falaiService.getTrainEndpoint());
server/test-falai.ts:    console.log('Generate endpoint:', falaiService.getGenerateEndpoint());
server/test-falai.ts:    console.log('Training status endpoint:', falaiService.getTrainingStatusEndpoint('test-lora-id'));
server/test-falai.ts:    console.log('Generation status endpoint:', falaiService.getGenerationStatusEndpoint('test-request-id'));
server/test-falai.ts:      const result = await falaiService.checkTrainingStatus(id, 1);
server/test-falai.ts:      const result = await falaiService.checkGenerationStatus(id, 1);
server/services/falai-mock.ts:import { KlingTrainingResponse, KlingGenerationResponse } from './falai';
server/services/falai.ts:} from './falai-errors';
server/services/falai.ts:// Constants for fal.ai endpoints
server/services/falai.ts:  DIRECT: 'direct',        // Direct connection to apifal.ai
server/services/falai.ts:  [CONNECTIVITY_OPTIONS.DIRECT]: "https://api.fal.ai",
server/services/falai.ts:  [CONNECTIVITY_OPTIONS.LOCAL_PROXY]: "/api/fal-proxy",
server/services/falai.ts:  [CONNECTIVITY_OPTIONS.CORS_PROXY]: "https://corsproxy.io/?https://api.fal.ai"
server/services/falai.ts:const KLING_API_TRAIN_URL = "/v2/fal/klingtube/train";
server/services/falai.ts:const KLING_API_GENERATE_URL = "/v2/fal/klingtube/generate";
server/services/falai.ts:const KLING_API_CHECK_TRAINING_URL = "/v2/fal/klingtube/check-training";
server/services/falai.ts:const KLING_API_CHECK_GENERATION_URL = "/v2/fal/klingtube/check-generation";
server/services/falai.ts: * Service to interact with fal.ai's Kling API
server/services/falai.ts:      console.log(`Making request to fal.ai for LoRA training, payload size: ${requestPayloadSize} bytes`);
server/services/falai.ts:      console.log(`Making request to fal.ai for video generation, payload size: ${requestPayloadSize} bytes`);
server/services/falai.ts:export const falaiService = new FalAIService();
server/services/emailService.ts:    this.isConfigured = false;
server/services/emailService.ts:      this.isConfigured = false;
server/services/emailService.ts:   * @returns Promise resolving to true if sent successfully, false otherwise
server/services/emailService.ts:      return false;
server/services/emailService.ts:      // Ensure fromEmail is a string by using the fallback
server/services/emailService.ts:      return false;
server/services/emailService.ts:   * @returns Promise resolving to true if sent successfully, false otherwise
server/services/emailService.ts:      return false;
server/services/emailService.ts:   * @returns Promise resolving to true if sent successfully, false otherwise
server/services/emailService.ts:    // Use the notification email from the video first, if available, otherwise fall back to user email
server/services/emailService.ts:      return false;
server/services/replicate.ts:  private debug: boolean = false;
server/services/replicate.ts:        success: false, 
server/services/replicate.ts:      // Using primary model first, will fall back to backup if needed
server/vite.ts:    configFile: false,
server/vite.ts:  // fall through to index.html if the file doesn't exist
server/index.ts:app.use(express.urlencoded({ extended: false, limit: '50mb' }));
server/routes.ts:                console.log(`Video completion email sent to ${user.email} (fallback to original video)`);
server/routes.ts:          success: false,
server/routes.ts:          hasToken: false
server/routes.ts:        success: false,
root@replit:~/vota-app# cd ~/vota-app
ls -la server/services/
total 92
drwxr-xr-x 2 root root  4096 Apr 27 09:10 .
drwxr-xr-x 4 root root  4096 Apr 27 09:34 ..
-rw-r--r-- 1 root root  3370 Apr 26 21:52 costTracker.ts
-rw-r--r-- 1 root root  6744 Apr 26 21:52 emailService.ts
-rw-r--r-- 1 root root  4230 Apr 26 21:52 falai-errors.ts
-rw-r--r-- 1 root root  7293 Apr 26 21:52 falai-mock.ts
-rw-r--r-- 1 root root 24594 Apr 26 21:52 falai.ts
-rw-r--r-- 1 root root 24663 Apr 26 21:52 replicate.ts
root@replit:~/vota-app# cd ~/vota-app
cat server/services/replicate.ts
# Or
cat server/services/falai.ts
# Or whatever service files are found
/**
 * Replicate API Integration Service
 * 
 * This service handles all interactions with the Replicate API, including:
 * - Video generation using public models
 * - Face extraction from user videos
 * - Face swapping onto generated videos
 * 
 * The service also tracks API usage and costs through the costTrackerService.
 */

import fetch from 'node-fetch';
import { costTrackerService } from './costTracker';

// API Endpoint and model versions
const REPLICATE_API_URL = 'https://api.replicate.com/v1/predictions';
// Public and accessible models that don't require special access - various options to try
const VIDEO_MODEL = 'stability-ai/stable-video-diffusion:3f0457e4619daac51203dedb472816fd4af51f3149fa7a9e0b5ffcf1b8172438';
// Alternative public models if the main one isn't available
const BACKUP_VIDEO_MODELS = [
  // Animov - popular text-to-video model
  'cjwbw/damo-text-to-video:1e205ea73084bd1f48cf12292218629e3b9fd9e63fc45f7c34a0267a4a8c175e',
  // Stable video diffusion model
  'stability-ai/stable-video-diffusion:cf91c35338de27f2a2e4e00358c1e6acca289577de01f59ca9fed2c556c28c60',
  // Zeroscope model
  'anotherjesse/zeroscope-v2-xl:9f747673945c62801b13b4a6f2fa26925f92c4193684f23e1dc6d7fa88710286', 
  // Another animation model
  'cerspense/zeroscope_v2_576w:63da0069206d88e3808a349a1cd9a07d39123e0e8c83566abbad0ddb8580e9c5'
];
const FACE_SWAP_MODEL = 'lucataco/faceswap-plus:0d9b8ab75eea7b60486fbc361a4566438e84c2f693aeb15af9ab36048b21ac95';
const FACE_EXTRACT_MODEL = 'xinntao/facexlib:c455e6fa874b7ec9f64c5eca07fa1688fe1c2c151ce507e03b03ba5a550589f5';

// Types for API responses
interface ReplicateResponse {
  id: string;
  status: string;
  output?: string | string[] | null;
  error?: string | null;
}

export class ReplicateService {
  private apiKey: string;
  private debug: boolean = false;
  
  constructor() {
    const apiKey = process.env.REPLICATE_API_TOKEN;
    if (!apiKey) {
      throw new Error('REPLICATE_API_TOKEN is not set in environment variables');
    }
    this.apiKey = apiKey;
  }
  
  /**
   * Enable or disable debug mode
   */
  setDebugMode(debug: boolean): void {
    this.debug = debug;
    console.log(`Replicate debug mode: ${debug ? 'enabled' : 'disabled'}`);
  }
  
  /**
   * Test connection to the Replicate API
   * @returns Promise with a boolean indicating if the connection was successful
   */
  async testConnection(): Promise<{ success: boolean; message: string }> {
    try {
      // Make a simple GET request to the API to verify connectivity
      const response = await fetch('https://api.replicate.com/v1', {
        method: 'GET',
        headers: {
          'Authorization': `Token ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const data = await response.json();
      
      return {
        success: response.ok,
        message: response.ok 
          ? "Successfully connected to Replicate API" 
          : `Failed to connect to Replicate API: ${JSON.stringify(data)}`
      };
    } catch (error) {
      return {
        success: false, 
        message: `Failed to connect to Replicate API: ${(error as Error).message}`
      };
    }
  }
  
  /**
   * Generate a video using Stable Video Diffusion
   * @param prompt Text prompt for video generation
   * @param userId User ID for cost tracking
   * @param options Additional options for the model
   * @returns Promise with the prediction ID and status
   */
  async generateVideo(
    prompt: string,
    userId: number,
    options: {
      negativePrompt?: string;
      aspectRatio?: string;
      duration?: string;
      cfgScale?: string;
    } = {}
  ): Promise<ReplicateResponse> {
    const startTime = Date.now();
    
    try {
      // Prepare the request payload
      // Convert parameters to expected types
      const duration = Number(options.duration || 5);
      const guidanceScale = Number(options.cfgScale || 7.5);
      
      if (this.debug) {
        console.log(`Converting parameters - duration: ${options.duration} -> ${duration}, cfgScale: ${options.cfgScale} -> ${guidanceScale}`);
      }
      
      // Using primary model first, will fall back to backup if needed
      const payload = {
        version: VIDEO_MODEL,
        input: {
          prompt: prompt,
          num_frames: 24,
          fps: 8
        }
      };
      
      // Make the API request
      if (this.debug) {
        console.log('Generating video with payload:', JSON.stringify(payload, null, 2));
      }
      
      const response = await fetch(REPLICATE_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Token ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
      
      // Parse the response
      const responseData = await response.json() as ReplicateResponse;
      
      if (this.debug) {
        console.log('Video generation response:', JSON.stringify(responseData, null, 2));
      }
      
      // Check if the response contains an error
      if (!response.ok || responseData.error) {
        console.error('Replicate API error with primary model:', responseData.error || 'Unknown error');
        console.error('Response status:', response.status);
        console.error('Response body:', JSON.stringify(responseData));
        
        // Track API usage with error
        await costTrackerService.trackApiUsage(
          userId,
          'replicate/primary-model-error',
          responseData.id || null,
          JSON.stringify(payload).length,
          JSON.stringify(responseData).length,
          'error',
          responseData.error || `API returned ${response.status}`,
          Date.now() - startTime
        );
        
        // Try all backup models one by one
        console.log('Trying backup models sequentially...');
        
        // Keep track of all errors for reporting
        const errors: string[] = [`Primary model error: ${responseData.error || `API returned ${response.status}`}`];
        
        // Try each backup model in order
        for (let i = 0; i < BACKUP_VIDEO_MODELS.length; i++) {
          const backupModel = BACKUP_VIDEO_MODELS[i];
          console.log(`Trying backup model ${i+1}/${BACKUP_VIDEO_MODELS.length}: ${backupModel}`);
          
          // Prepare specific payload based on the model type
          let backupPayload: any;
          
          // Different models require different input formats
          if (backupModel.includes('zeroscope')) {
            backupPayload = {
              version: backupModel,
              input: {
                prompt: prompt
              }
            };
          } else if (backupModel.includes('stability-ai')) {
            backupPayload = {
              version: backupModel,
              input: {
                prompt: prompt,
                video_length: "14_frames_with_svd",
                sizing_strategy: "maintain_aspect_ratio",
                frames_per_second: 7
              }
            };
          } else {
            // Default format for other models
            backupPayload = {
              version: backupModel,
              input: {
                prompt: prompt,
                width: 512,
                height: 512,
                num_frames: 24,
                fps: 8
              }
            };
          }
          
          if (this.debug) {
            console.log(`Generating video with backup model ${i+1} payload:`, JSON.stringify(backupPayload, null, 2));
          }
          
          try {
            const backupResponse = await fetch(REPLICATE_API_URL, {
              method: 'POST',
              headers: {
                'Authorization': `Token ${this.apiKey}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(backupPayload)
            });
            
            // Parse the backup response
            const backupResponseData = await backupResponse.json() as ReplicateResponse;
            
            if (this.debug) {
              console.log(`Backup model ${i+1} video generation response:`, JSON.stringify(backupResponseData, null, 2));
            }
            
            // Check if this model worked
            if (backupResponse.ok && !backupResponseData.error) {
              // Success! Return this model's response
              console.log(`Successfully generated video with backup model ${i+1}: ${backupModel}`);
              
              // Track API usage for successful backup model
              await costTrackerService.trackApiUsage(
                userId,
                `replicate/backup-model-${i+1}-success`,
                backupResponseData.id,
                JSON.stringify(backupPayload).length,
                JSON.stringify(backupResponseData).length,
                'success',
                null,
                Date.now() - startTime
              );
              
              return backupResponseData;
            }
            
            // If we're here, this model also failed
            console.error(`Backup model ${i+1} failed:`, backupResponseData.error || 'Unknown error');
            errors.push(`Backup model ${i+1} error: ${backupResponseData.error || `API returned ${backupResponse.status}`}`);
            
            // Track API usage with error for this backup model
            await costTrackerService.trackApiUsage(
              userId,
              `replicate/backup-model-${i+1}-error`,
              backupResponseData.id || null,
              JSON.stringify(backupPayload).length,
              JSON.stringify(backupResponseData).length,
              'error',
              backupResponseData.error || `API returned ${backupResponse.status}`,
              Date.now() - startTime
            );
            
          } catch (modelError) {
            console.error(`Error with backup model ${i+1}:`, modelError);
            errors.push(`Backup model ${i+1} exception: ${(modelError as Error).message}`);
          }
        }
        
        // If we reach here, all models failed
        console.error('All video generation models failed');
        const errorMessage = `All video generation models failed: ${errors.join(', ')}`;
        throw new Error(errorMessage);
      }
      
      // Track API usage (success case)
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/stable-video-diffusion',
        responseData.id,
        JSON.stringify(payload).length,
        JSON.stringify(responseData).length,
        'success',
        null,
        Date.now() - startTime
      );
      
      return responseData;
    } catch (error) {
      console.error('Error in Replicate video generation:', error);
      
      // Track API usage error
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/stable-video-diffusion',
        null,
        0,
        0,
        'error',
        (error as Error).message,
        Date.now() - startTime
      );
      
      throw error;
    }
  }
  
  /**
   * Check the status of a video generation job
   * @param predictionId Prediction ID from the initial request
   * @param userId User ID for cost tracking
   * @returns Promise with the current status and output (if completed)
   */
  async checkVideoStatus(predictionId: string, userId: number): Promise<ReplicateResponse> {
    const startTime = Date.now();
    
    try {
      // Make the API request
      const response = await fetch(`${REPLICATE_API_URL}/${predictionId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Token ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });
      
      // Parse the response
      const responseData = await response.json() as ReplicateResponse;
      
      if (this.debug) {
        console.log('Video status check response:', JSON.stringify(responseData, null, 2));
      }
      
      // Check if the response contains an error
      if (!response.ok || responseData.error) {
        console.error('Replicate status check API error:', responseData.error || 'Unknown error');
        console.error('Response status:', response.status);
        console.error('Response body:', JSON.stringify(responseData));
        
        // Track API usage with error
        await costTrackerService.trackApiUsage(
          userId,
          'replicate/status-check',
          predictionId,
          0,
          JSON.stringify(responseData).length,
          'error',
          responseData.error || `API returned ${response.status}`,
          Date.now() - startTime
        );
        
        // Throw a detailed error
        throw new Error(`Replicate status check API error: ${responseData.error || `API returned ${response.status}`}`);
      }
      
      // Track API usage (success case)
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/status-check',
        predictionId,
        0,
        JSON.stringify(responseData).length,
        'success',
        null,
        Date.now() - startTime
      );
      
      // Process output if it's an array (some models like Stable Video Diffusion return an array)
      if (responseData.status === 'succeeded' && Array.isArray(responseData.output) && responseData.output.length > 0) {
        // The first URL in the array is the video
        responseData.output = responseData.output[0];
      }
      
      return responseData;
    } catch (error) {
      console.error('Error checking video status:', error);
      
      // Track API usage error
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/status-check',
        predictionId,
        0,
        0,
        'error',
        (error as Error).message,
        Date.now() - startTime
      );
      
      throw error;
    }
  }
  
  /**
   * Swap a face from a source image onto a target video
   * @param targetVideoUrl URL of the video to swap onto
   * @param sourceImageUrl URL of the image containing the face to use
   * @param userId User ID for cost tracking
   * @returns Promise with the prediction ID and status
   */
  async swapFace(
    targetVideoUrl: string,
    sourceImageUrl: string,
    userId: number
  ): Promise<ReplicateResponse> {
    const startTime = Date.now();
    
    try {
      // Prepare the request payload
      const payload = {
        version: FACE_SWAP_MODEL,
        input: {
          target_image: targetVideoUrl,
          source_image: sourceImageUrl,
          face_index: 0, // Swap the first face found
          keep_fps: true
        }
      };
      
      // Make the API request
      if (this.debug) {
        console.log('Face swap with payload:', JSON.stringify(payload, null, 2));
      }
      
      const response = await fetch(REPLICATE_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Token ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
      
      // Parse the response
      const responseData = await response.json() as ReplicateResponse;
      
      if (this.debug) {
        console.log('Face swap response:', JSON.stringify(responseData, null, 2));
      }
      
      // Check if the response contains an error
      if (!response.ok || responseData.error) {
        console.error('Replicate face swap API error:', responseData.error || 'Unknown error');
        console.error('Response status:', response.status);
        console.error('Response body:', JSON.stringify(responseData));
        
        // Track API usage with error
        await costTrackerService.trackApiUsage(
          userId,
          'replicate/face-swap',
          responseData.id || null,
          JSON.stringify(payload).length,
          JSON.stringify(responseData).length,
          'error',
          responseData.error || `API returned ${response.status}`,
          Date.now() - startTime
        );
        
        // Throw a detailed error
        throw new Error(`Replicate face swap API error: ${responseData.error || `API returned ${response.status}`}`);
      }
      
      // Track API usage (success case)
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/face-swap',
        responseData.id,
        JSON.stringify(payload).length,
        JSON.stringify(responseData).length,
        'success',
        null,
        Date.now() - startTime
      );
      
      return responseData;
    } catch (error) {
      console.error('Error in face swap:', error);
      
      // Track API usage error
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/face-swap',
        null,
        0,
        0,
        'error',
        (error as Error).message,
        Date.now() - startTime
      );
      
      throw error;
    }
  }
  
  /**
   * Check the status of a face swap job
   * @param predictionId Prediction ID from the initial request
   * @param userId User ID for cost tracking
   * @returns Promise with the current status and output (if completed)
   */
  async checkFaceSwapStatus(predictionId: string, userId: number): Promise<ReplicateResponse> {
    const startTime = Date.now();
    
    try {
      // Make the API request
      const response = await fetch(`${REPLICATE_API_URL}/${predictionId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Token ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });
      
      // Parse the response
      const responseData = await response.json() as ReplicateResponse;
      
      if (this.debug) {
        console.log('Face swap status check response:', JSON.stringify(responseData, null, 2));
      }
      
      // Track API usage for status check
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/status-check',
        predictionId,
        0,
        JSON.stringify(responseData).length,
        response.ok ? 'success' : 'error',
        response.ok ? null : responseData.error || 'Unknown error',
        Date.now() - startTime
      );
      
      return responseData;
    } catch (error) {
      console.error('Error checking face swap status:', error);
      
      // Track API usage error
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/status-check',
        predictionId,
        0,
        0,
        'error',
        (error as Error).message,
        Date.now() - startTime
      );
      
      throw error;
    }
  }
  
  /**
   * Extract a face from a video or image
   * @param videoData Base64 encoded image or video data
   * @param userId User ID for cost tracking
   * @returns URL to the extracted face image
   */
  async extractFace(videoData: string, userId: number): Promise<string> {
    const startTime = Date.now();
    
    try {
      console.log("Starting face extraction from video data...");
      
      // Prepare the request payload for face extraction
      const payload = {
        version: FACE_EXTRACT_MODEL,
        input: {
          image: videoData,
          detection_size: 640 // Default size for face detection
        }
      };
      
      if (this.debug) {
        console.log('Face extraction payload prepared (truncated for logs)');
      }
      
      // Make the API request
      const response = await fetch(REPLICATE_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Token ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
      
      // Parse the response
      const responseData = await response.json() as ReplicateResponse;
      
      if (this.debug) {
        console.log('Face extraction initial response:', JSON.stringify(responseData, null, 2));
      }
      
      // Check if the response contains an error
      if (!response.ok || responseData.error) {
        console.error('Replicate face extraction API error:', responseData.error || 'Unknown error');
        console.error('Response status:', response.status);
        console.error('Response body:', JSON.stringify(responseData));
        
        // Track API usage with error
        await costTrackerService.trackApiUsage(
          userId,
          'replicate/face-extraction',
          responseData.id || null,
          JSON.stringify(payload).length > 1000 ? 'large_payload' : JSON.stringify(payload).length.toString(),
          JSON.stringify(responseData).length,
          'error',
          responseData.error || `API returned ${response.status}`,
          Date.now() - startTime
        );
        
        // For demo purposes, return a placeholder face URL
        return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
      }
      
      // Wait for the face extraction to complete
      const extractionId = responseData.id;
      let extractionResult: ReplicateResponse | null = null;
      let maxAttempts = 20;
      let attempt = 0;
      
      while (attempt < maxAttempts) {
        attempt++;
        
        // Check the status of the face extraction
        const statusResponse = await fetch(`${REPLICATE_API_URL}/${extractionId}`, {
          method: 'GET',
          headers: {
            'Authorization': `Token ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        });
        
        const statusData = await statusResponse.json() as ReplicateResponse;
        
        if (this.debug) {
          console.log(`Face extraction status check (attempt ${attempt}):`, JSON.stringify(statusData, null, 2));
        }
        
        if (statusData.status === 'succeeded' && statusData.output) {
          extractionResult = statusData;
          break;
        } else if (statusData.status === 'failed') {
          console.error('Face extraction failed:', statusData.error);
          
          // Track API usage for failed extraction
          await costTrackerService.trackApiUsage(
            userId,
            'replicate/face-extraction',
            extractionId,
            'large_payload',
            JSON.stringify(statusData).length,
            'error',
            statusData.error || 'Face extraction failed',
            Date.now() - startTime
          );
          
          // For demo purposes, return a placeholder face URL
          return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
        }
        
        // Wait a bit before checking again
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
      if (!extractionResult || !extractionResult.output) {
        console.error('Face extraction timed out or failed to produce output');
        
        // Track API usage for timed out extraction
        await costTrackerService.trackApiUsage(
          userId,
          'replicate/face-extraction',
          extractionId,
          'large_payload',
          0,
          'error',
          'Face extraction timed out',
          Date.now() - startTime
        );
        
        // For demo purposes, return a placeholder face URL
        return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
      }
      
      // Get the face image URL from the extraction result
      const faceImageUrl = Array.isArray(extractionResult.output)
        ? extractionResult.output[0]
        : extractionResult.output as string;
      
      console.log('Face extraction completed successfully, face image URL:', faceImageUrl);
      
      // Track API usage for successful extraction
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/face-extraction',
        extractionId,
        'large_payload',
        faceImageUrl.length,
        'success',
        null,
        Date.now() - startTime
      );
      
      return faceImageUrl;
    } catch (error) {
      console.error('Error in face extraction:', error);
      
      // Track API usage error
      await costTrackerService.trackApiUsage(
        userId,
        'replicate/face-extraction',
        null,
        'large_payload',
        0,
        'error',
        (error as Error).message,
        Date.now() - startTime
      );
      
      // For demo purposes, return a placeholder face URL
      return "https://replicate.delivery/pbxt/7oFCB2DH1fJtKSZza4upYNH7ZS03lMiAy3fNaP09YWzONUOIA/face.png";
    }
  }
}

export const replicateService = new ReplicateService();import fetch from 'node-fetch';
import { costTrackerService } from './costTracker';
import {
  FalError, FalConfigError, FalAuthError, FalApiError,
  FalTrainingError, FalGenerationError, getSolutionForError
} from './falai-errors';

// Constants for fal.ai endpoints
// Network connectivity options
const CONNECTIVITY_OPTIONS = {
  DIRECT: 'direct',        // Direct connection to api.fal.ai
  LOCAL_PROXY: 'local',    // Use our local proxy endpoints
  CORS_PROXY: 'cors'       // Use a public CORS proxy service
};

// Choose which connectivity option to use (modify this if one approach doesn't work)
const CONNECTIVITY_OPTION = CONNECTIVITY_OPTIONS.CORS_PROXY;

// Define different access URLs based on the connectivity option
const API_URLS = {
  [CONNECTIVITY_OPTIONS.DIRECT]: "https://api.fal.ai",
  [CONNECTIVITY_OPTIONS.LOCAL_PROXY]: "/api/fal-proxy",
  [CONNECTIVITY_OPTIONS.CORS_PROXY]: "https://corsproxy.io/?https://api.fal.ai"
};

// Select the API URL based on the connectivity option
const FAL_API_URL = API_URLS[CONNECTIVITY_OPTION];

// API endpoint paths
const KLING_API_TRAIN_URL = "/v2/fal/klingtube/train";
const KLING_API_GENERATE_URL = "/v2/fal/klingtube/generate";
const KLING_API_CHECK_TRAINING_URL = "/v2/fal/klingtube/check-training";
const KLING_API_CHECK_GENERATION_URL = "/v2/fal/klingtube/check-generation";

// Types for API responses
export interface KlingTrainingResponse {
  request_id?: string;
  lora_id?: string;
  status?: string;
  error?: string;
}

export interface KlingGenerationResponse {
  request_id?: string;
  status?: string;
  video_url?: string;
  thumbnail_url?: string;
  error?: string;
}

export { 
  FalError, FalConfigError, FalAuthError, FalApiError,
  FalTrainingError, FalGenerationError, getSolutionForError
};

/**
 * Service to interact with fal.ai's Kling API
 */
export class FalAIService {
  private apiKey: string;
  private debugMode: boolean;

  constructor() {
    if (!process.env.FAL_KEY) {
      throw new FalConfigError("FAL_KEY environment variable is not set. Please set it to use the Fal.ai service.");
    }
    this.apiKey = process.env.FAL_KEY;
    this.debugMode = process.env.FAL_DEBUG?.toLowerCase() === 'true';
    
    if (this.debugMode) {
      this.debugLog('Initialized Fal.ai service with debug mode enabled');
    }
  }
  
  /**
   * Enable or disable debug mode
   * @param enabled Whether debug mode should be enabled
   */
  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;
    this.debugLog(`Debug mode ${enabled ? 'enabled' : 'disabled'}`);
  }
  
  /**
   * Check if debug mode is enabled
   * @returns Whether debug mode is enabled
   */
  isDebugMode(): boolean {
    return this.debugMode;
  }
  
  /**
   * Log a message only when in debug mode
   * @param message The message to log
   * @param data Optional data to log
   */
  private debugLog(message: string, data?: any): void {
    if (this.debugMode) {
      console.log(`[FAL-DEBUG] ${message}`);
      if (data !== undefined) {
        console.log(data);
      }
    }
  }
  
  /**
   * Get the full URL for the training endpoint
   * @returns The full URL for the training endpoint
   */
  getTrainEndpoint(): string {
    return `${FAL_API_URL}${KLING_API_TRAIN_URL}`;
  }
  
  /**
   * Get the full URL for the video generation endpoint
   * @returns The full URL for the video generation endpoint
   */
  getGenerateEndpoint(): string {
    return `${FAL_API_URL}${KLING_API_GENERATE_URL}`;
  }
  
  /**
   * Get the full URL for checking training status
   * @param loraId The LoRA ID to check
   * @returns The full URL for checking training status
   */
  getTrainingStatusEndpoint(loraId: string): string {
    return `${FAL_API_URL}${KLING_API_CHECK_TRAINING_URL}?lora_id=${loraId}`;
  }
  
  /**
   * Get the full URL for checking generation status
   * @param requestId The request ID to check
   * @returns The full URL for checking generation status
   */
  getGenerationStatusEndpoint(requestId: string): string {
    return `${FAL_API_URL}${KLING_API_CHECK_GENERATION_URL}?request_id=${requestId}`;
  }

  /**
   * Submits a video for LoRA training
   * @param videoData Base64 encoded video data
   * @param userId User ID for tracking
   * @returns Promise with the training response including loraId
   */
  async trainLora(videoData: string, userId: number): Promise<KlingTrainingResponse> {
    const startTime = Date.now();
    let status = 'success';
    let errorMessage = '';
    let responseData: Record<string, any> = {};
    let requestPayloadSize = 0;
    
    try {
      // More detailed debug logging
      console.log("==== FAL.AI LORA TRAINING REQUEST START ====");
      console.log(`Video data length: ${videoData.length} characters`);
      console.log(`User ID: ${userId}`);
      console.log(`API Key present: ${!!this.apiKey}`);
      console.log(`Debug mode: ${this.debugMode}`);
      
      // Log the action in debug mode with detailed info
      this.debugLog(`Starting LoRA training for user ${userId}`, { 
        videoLength: videoData.length,
        timestamp: new Date().toISOString(),
        dataPrefix: videoData.substring(0, 100) // Show first 100 chars to verify format
      });
      
      console.log(`Starting LoRA training for user ${userId}, video length: ${videoData.length} chars`);
      
      // Check if video is too large and truncate if necessary
      const MAX_VIDEO_SIZE = 26000000; // ~26MB
      let processedVideoData = videoData;
      if (videoData.length > MAX_VIDEO_SIZE) {
        console.log(`Video data exceeds max size (${videoData.length} > ${MAX_VIDEO_SIZE}), truncating...`);
        this.debugLog(`Video data exceeds max size, truncating`, {
          originalSize: videoData.length,
          maxSize: MAX_VIDEO_SIZE
        });
        processedVideoData = videoData.substring(0, MAX_VIDEO_SIZE);
      }
      
      // Estimate request payload size
      const requestBody = JSON.stringify({
        video_input: processedVideoData,
        user_id: userId.toString(),
        webhook_url: process.env.NODE_ENV === 'production' 
          ? `${process.env.PUBLIC_URL}/api/webhooks/training-complete` 
          : null
      });
      
      requestPayloadSize = new TextEncoder().encode(requestBody).length;
      console.log(`Making request to fal.ai for LoRA training, payload size: ${requestPayloadSize} bytes`);
      this.debugLog(`Making LoRA training request`, {
        endpoint: this.getTrainEndpoint(),
        payloadSize: requestPayloadSize,
        includesWebhook: process.env.NODE_ENV === 'production'
      });
      
      try {
        const response = await fetch(this.getTrainEndpoint(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Key ${this.apiKey}`,
          },
          body: requestBody,
        });
  
        if (!response.ok) {
          const errorText = await response.text();
          status = 'error';
          errorMessage = errorText;
          
          // Log detailed error info in debug mode
          this.debugLog(`Failed to train LoRA`, {
            status: response.status,
            statusText: response.statusText,
            errorText: errorText
          });
          
          console.error(`Failed to train LoRA: ${errorText}, HTTP status: ${response.status}`);
          
          // Handle specific error status codes
          if (response.status === 401 || response.status === 403) {
            throw new FalAuthError(
              `Authentication failed with Fal.ai API: ${errorText}`, 
              new Error(`HTTP ${response.status}: ${errorText}`)
            );
          } else {
            throw new FalApiError(
              `Failed to train LoRA: ${errorText}`,
              response.status,
              errorText,
              this.getTrainEndpoint()
            );
          }
        }
  
        // Use type assertion to handle the JSON response
        responseData = await response.json() as Record<string, any>;
        
        this.debugLog(`LoRA training initiated successfully`, responseData);
        console.log(`LoRA training initiated successfully, response:`, responseData);
        
      } catch (fetchError: any) {
        // Re-throw if it's already one of our custom errors
        if (fetchError instanceof FalError) {
          throw fetchError;
        }
        
        // Network errors or other fetch problems
        throw new FalApiError(
          `Network error connecting to Fal.ai: ${fetchError.message}`,
          0,
          fetchError.message,
          this.getTrainEndpoint()
        );
      }
      
      // Track API usage
      const responsePayloadSize = new TextEncoder().encode(JSON.stringify(responseData)).length;
      const duration = Date.now() - startTime;
      
      await costTrackerService.trackApiUsage(
        userId,
        'train',
        responseData.request_id,
        requestPayloadSize,
        responsePayloadSize,
        status,
        errorMessage,
        duration
      );
      
      return responseData;
    } catch (error: any) {
      // Log the error in detail with more information
      console.log("==== FAL.AI LORA TRAINING ERROR ====");
      console.log(`Error message: ${error.message}`);
      console.log(`Error type: ${error.constructor.name}`);
      console.log(`Error code: ${error.code || 'N/A'}`);
      if (error.stack) {
        console.log("Error stack trace:");
        console.log(error.stack);
      }
      
      this.debugLog('Error in trainLora', {
        error: error.message,
        code: error.code,
        name: error.name,
        stack: error.stack,
        fullError: JSON.stringify(error)
      });
      
      console.error('Error training LoRA:', error);
      
      // Still track API usage in case of error
      if (status === 'success') {
        status = 'error';
        errorMessage = error?.message || 'Unknown error';
      }
      
      await costTrackerService.trackApiUsage(
        userId,
        'train',
        undefined,
        requestPayloadSize,
        0,
        status,
        errorMessage,
        Date.now() - startTime
      );
      
      // Convert to a FalTrainingError if it's not already a FalError
      if (!(error instanceof FalError)) {
        throw new FalTrainingError(
          `Failed to train LoRA model: ${error.message}`,
          undefined,
          'failed',
          error
        );
      }
      
      throw error;
    }
  }

  /**
   * Checks the status of a LoRA training job
   * @param loraId ID of the training job
   * @returns Promise with the training status
   */
  async checkTrainingStatus(loraId: string, userId: number): Promise<KlingTrainingResponse> {
    const startTime = Date.now();
    let status = 'success';
    let errorMessage = '';
    let responseData: Record<string, any> = {};
    
    try {
      console.log(`Checking training status for LoRA ID: ${loraId}, user: ${userId}`);
      this.debugLog(`Checking training status`, { loraId, userId });
      
      try {
        const response = await fetch(this.getTrainingStatusEndpoint(loraId), {
          method: 'GET',
          headers: {
            'Authorization': `Key ${this.apiKey}`,
          },
        });
  
        if (!response.ok) {
          const errorText = await response.text();
          status = 'error';
          errorMessage = errorText;
          
          this.debugLog(`Failed to check training status`, {
            status: response.status,
            statusText: response.statusText,
            errorText: errorText
          });
          
          console.error(`Failed to check training status: ${errorText}, HTTP status: ${response.status}`);
          
          // Handle specific error status codes
          if (response.status === 401 || response.status === 403) {
            throw new FalAuthError(
              `Authentication failed with Fal.ai API: ${errorText}`, 
              new Error(`HTTP ${response.status}: ${errorText}`)
            );
          } else {
            throw new FalApiError(
              `Failed to check training status: ${errorText}`,
              response.status,
              errorText,
              this.getTrainingStatusEndpoint(loraId)
            );
          }
        }
  
        // Use type assertion to handle the JSON response
        responseData = await response.json() as Record<string, any>;
        
        this.debugLog(`Training status check successful`, {
          loraId,
          status: responseData.status || 'unknown',
          response: responseData
        });
        
        console.log(`Training status for LoRA ID ${loraId}: ${responseData.status || 'unknown'}`);
      } catch (fetchError: any) {
        // Re-throw if it's already one of our custom errors
        if (fetchError instanceof FalError) {
          throw fetchError;
        }
        
        // Network errors or other fetch problems
        throw new FalApiError(
          `Network error connecting to Fal.ai: ${fetchError.message}`,
          0,
          fetchError.message,
          this.getTrainingStatusEndpoint(loraId)
        );
      }
      
      // Track API usage
      const requestSize = new TextEncoder().encode(loraId).length;
      const responseSize = new TextEncoder().encode(JSON.stringify(responseData)).length;
      const duration = Date.now() - startTime;
      
      await costTrackerService.trackApiUsage(
        userId,
        'check-training-status',
        undefined,
        requestSize,
        responseSize,
        status,
        errorMessage,
        duration
      );
      
      return responseData;
    } catch (error: any) {
      // Log the error in detail
      this.debugLog('Error in checkTrainingStatus', {
        error: error.message,
        code: error.code,
        name: error.name,
        stack: error.stack
      });
      
      console.error('Error checking training status:', error);
      
      if (status === 'success') {
        status = 'error';
        errorMessage = error?.message || 'Unknown error';
      }
      
      await costTrackerService.trackApiUsage(
        userId,
        'check-training-status',
        undefined,
        0,
        0,
        status,
        errorMessage,
        Date.now() - startTime
      );
      
      // Convert to a FalTrainingError if it's not already a FalError
      if (!(error instanceof FalError)) {
        throw new FalTrainingError(
          `Failed to check LoRA training status: ${error.message}`,
          loraId,
          'failed',
          error
        );
      }
      
      throw error;
    }
  }

  /**
   * Generates a video using a trained LoRA model
   * @param loraId ID of the trained LoRA model
   * @param prompt Text prompt for video generation
   * @returns Promise with the generated video URL
   */
  async generateVideo(loraId: string, prompt: string, userId: number): Promise<KlingGenerationResponse> {
    const startTime = Date.now();
    let status = 'success';
    let errorMessage = '';
    let responseData: Record<string, any> = {};
    let requestPayloadSize = 0;
    
    try {
      console.log(`Starting video generation for user ${userId} with LoRA ID: ${loraId}`);
      console.log(`Using prompt: "${prompt}"`);
      
      this.debugLog(`Starting video generation`, {
        userId,
        loraId,
        prompt,
        timestamp: new Date().toISOString()
      });
      
      // Estimate request payload size
      const requestBody = JSON.stringify({
        lora_id: loraId,
        prompt: prompt,
        negative_prompt: "bad quality, blurry, watermark, text, pixelated",
        num_frames: 25,
        num_inference_steps: 50,
        webhook_url: process.env.NODE_ENV === 'production' 
          ? `${process.env.PUBLIC_URL}/api/webhooks/video-complete` 
          : null
      });
      
      requestPayloadSize = new TextEncoder().encode(requestBody).length;
      console.log(`Making request to fal.ai for video generation, payload size: ${requestPayloadSize} bytes`);
      
      this.debugLog(`Making video generation request`, {
        endpoint: this.getGenerateEndpoint(),
        payloadSize: requestPayloadSize,
        includesWebhook: process.env.NODE_ENV === 'production',
        requestParams: {
          loraId,
          prompt: prompt.substring(0, 50) + (prompt.length > 50 ? '...' : ''), // Truncate long prompts in logs
          numFrames: 25,
          numInferenceSteps: 50
        }
      });
      
      try {
        const response = await fetch(this.getGenerateEndpoint(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Key ${this.apiKey}`,
          },
          body: requestBody,
        });
  
        if (!response.ok) {
          const errorText = await response.text();
          status = 'error';
          errorMessage = errorText;
          
          this.debugLog(`Failed to generate video`, {
            status: response.status,
            statusText: response.statusText,
            errorText: errorText
          });
          
          console.error(`Failed to generate video: ${errorText}, HTTP status: ${response.status}`);
          
          // Handle specific error status codes
          if (response.status === 401 || response.status === 403) {
            throw new FalAuthError(
              `Authentication failed with Fal.ai API: ${errorText}`, 
              new Error(`HTTP ${response.status}: ${errorText}`)
            );
          } else {
            throw new FalApiError(
              `Failed to generate video: ${errorText}`,
              response.status,
              errorText,
              this.getGenerateEndpoint()
            );
          }
        }
  
        // Use type assertion to handle the JSON response
        responseData = await response.json() as Record<string, any>;
        
        this.debugLog(`Video generation initiated successfully`, responseData);
        console.log(`Video generation initiated successfully, response:`, responseData);
      } catch (fetchError: any) {
        // Re-throw if it's already one of our custom errors
        if (fetchError instanceof FalError) {
          throw fetchError;
        }
        
        // Network errors or other fetch problems
        throw new FalApiError(
          `Network error connecting to Fal.ai: ${fetchError.message}`,
          0,
          fetchError.message,
          this.getGenerateEndpoint()
        );
      }
      
      // Track API usage
      const responsePayloadSize = new TextEncoder().encode(JSON.stringify(responseData)).length;
      const duration = Date.now() - startTime;
      
      await costTrackerService.trackApiUsage(
        userId,
        'generate',
        responseData.request_id,
        requestPayloadSize,
        responsePayloadSize,
        status,
        errorMessage,
        duration
      );
      
      return responseData;
    } catch (error: any) {
      // Log the error in detail
      this.debugLog('Error in generateVideo', {
        error: error.message,
        code: error.code,
        name: error.name,
        stack: error.stack
      });
      
      console.error('Error generating video:', error);
      
      // Still track API usage in case of error
      if (status === 'success') {
        status = 'error';
        errorMessage = error?.message || 'Unknown error';
      }
      
      await costTrackerService.trackApiUsage(
        userId,
        'generate',
        undefined,
        requestPayloadSize,
        0,
        status,
        errorMessage,
        Date.now() - startTime
      );
      
      // Convert to a FalGenerationError if it's not already a FalError
      if (!(error instanceof FalError)) {
        throw new FalGenerationError(
          `Failed to generate video: ${error.message}`,
          undefined,
          'failed',
          error
        );
      }
      
      throw error;
    }
  }

  /**
   * Checks the status of a video generation job
   * @param requestId ID of the generation request
   * @returns Promise with the generation status
   */
  async checkGenerationStatus(requestId: string, userId: number): Promise<KlingGenerationResponse> {
    const startTime = Date.now();
    let status = 'success';
    let errorMessage = '';
    let responseData: Record<string, any> = {};
    
    try {
      console.log(`Checking generation status for request ID: ${requestId}, user: ${userId}`);
      this.debugLog(`Checking generation status`, { requestId, userId });
      
      try {
        const response = await fetch(this.getGenerationStatusEndpoint(requestId), {
          method: 'GET',
          headers: {
            'Authorization': `Key ${this.apiKey}`,
          },
        });
  
        if (!response.ok) {
          const errorText = await response.text();
          status = 'error';
          errorMessage = errorText;
          
          this.debugLog(`Failed to check generation status`, {
            status: response.status,
            statusText: response.statusText,
            errorText: errorText
          });
          
          console.error(`Failed to check generation status: ${errorText}, HTTP status: ${response.status}`);
          
          // Handle specific error status codes
          if (response.status === 401 || response.status === 403) {
            throw new FalAuthError(
              `Authentication failed with Fal.ai API: ${errorText}`, 
              new Error(`HTTP ${response.status}: ${errorText}`)
            );
          } else {
            throw new FalApiError(
              `Failed to check generation status: ${errorText}`,
              response.status,
              errorText,
              this.getGenerationStatusEndpoint(requestId)
            );
          }
        }
  
        // Use type assertion to handle the JSON response
        responseData = await response.json() as Record<string, any>;
        
        this.debugLog(`Generation status check successful`, {
          requestId,
          status: responseData.status || 'unknown',
          hasVideoUrl: !!responseData.video_url,
          response: responseData
        });
        
        console.log(`Generation status for request ID ${requestId}: ${responseData.status || 'unknown'}`);
        if (responseData.video_url) {
          console.log(`Video generation completed, URL: ${responseData.video_url}`);
        }
      } catch (fetchError: any) {
        // Re-throw if it's already one of our custom errors
        if (fetchError instanceof FalError) {
          throw fetchError;
        }
        
        // Network errors or other fetch problems
        throw new FalApiError(
          `Network error connecting to Fal.ai: ${fetchError.message}`,
          0,
          fetchError.message,
          this.getGenerationStatusEndpoint(requestId)
        );
      }
      
      // Track API usage
      const requestSize = new TextEncoder().encode(requestId).length;
      const responseSize = new TextEncoder().encode(JSON.stringify(responseData)).length;
      const duration = Date.now() - startTime;
      
      await costTrackerService.trackApiUsage(
        userId,
        'check-generation-status',
        requestId,
        requestSize,
        responseSize,
        status,
        errorMessage,
        duration
      );
      
      return responseData;
    } catch (error: any) {
      // Log the error in detail
      this.debugLog('Error in checkGenerationStatus', {
        error: error.message,
        code: error.code,
        name: error.name,
        stack: error.stack
      });
      
      console.error('Error checking generation status:', error);
      
      if (status === 'success') {
        status = 'error';
        errorMessage = error?.message || 'Unknown error';
      }
      
      await costTrackerService.trackApiUsage(
        userId,
        'check-generation-status',
        requestId,
        0,
        0,
        status,
        errorMessage,
        Date.now() - startTime
      );
      
      // Convert to a FalGenerationError if it's not already a FalError
      if (!(error instanceof FalError)) {
        throw new FalGenerationError(
          `Failed to check video generation status: ${error.message}`,
          requestId,
          'failed',
          error
        );
      }
      
      throw error;
    }
  }
}

export const falaiService = new FalAIService();root@replit:~/vota-app# # Or whatever service files are f